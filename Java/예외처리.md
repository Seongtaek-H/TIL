## 예외처리

> **예외(Exception)** : 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 발생하는 프로그램 오류

* 예외가 발생하면 프로그램은 곧바로 종료되나, 예외처리(Exception Handling)을 통해 정상 실행 상태 유지 가능



### 예외의 종류

`일반예외` : 컴파일하는 과정에서 예외 처리 코드를 검사하는 예외. java.lang.Exception 상속

`실행예외` : 컴파일하는 과정에서 예외 처리 코드를 검사하지 않는 예외. java.lang.RuntimeException 상속



### 실행예외

`NullPointerException` 

>  객체 참조가 없는 상태. null 값을 갖는 참조 변수로 도트(.)를 사용했을 때 발생.

```java
// 객체가 없는 상태에서 객체를 사용하려 해서 발생하는 예외
String data = null;
System.out.println(data.toString()); // 예외 발생
```



`ArrayIndexOutofBoundsException` 

> 배열에서 인덱스 범위를 초과하여 사용하는 경우 발생하는 예외

```java
int[] arr = new int[3];
int data = arr[3]; // 예외 발생
```



`NumberFormatException`

> 숫자로 변환될 수 없는 문자가 포함된 값을 Integer, Double 로 변환하려 할 때 발생



`ClassCastException`

> 타입 변환(casting)을 할 수 없는 경우인데 억지로 타입 변환하려 할 때 발생



### 예외 처리 코드

> 예외가 발생할 경우 프로그램의 종료를 막고, 정상 실행을 유지할 수 있도록 처리하는 코드.
>
> 일반 예외일 경우 컴파일 오류를 발생하나, 실행 예외는 컴파일러가 체크해주지 않기 때문에 개발자가 체크해주어야 함.

`try-catch-finally 블록`

```java
try {
    예외 발생 가능 코드;
} catch(예외클래스 e) {
    예외 처리 코드
} finally {
    항상 실행
}
```

* 정상 실행 되었을 경우 : try 실행 -> finally 실행
* 예외 발생 되었을 경우 : catch 실행 -> finally 실행
* finally 블록은 생략 가능. 반드시 실행할 내용이 있는 경우에만 작성

` 다중 catch`

```java
try {
    예외 발생 가능 코드;
} catch(예외클래스 e) {
    예외 처리1
} catch(예외클래스 e) {
    예외 처리2
} finally {
    항상 실행
}
```

* catch 블록이 여러개 일지라도 단 하나의 catch 블록만 실행. 예외가 발생하는 즉시 해당 catch블록으로 이동하기 때문.

* 다중 catch 블록을 작성할 때에는 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치. 예외 발생 시 상위 catch 블록부터 검색되기 때문

```java
try {
    ArrayIndexOutOfBoundException 발생 -> 예외 처리 1 부터 검색하여 실행
        
    NumberFormatException 발생    
} catch(Exception e) { // 예외 처리 최상의 클래스이므로 가장 하단에 위치하여 함.
    예외 처리1
} catch(ArrayIndexOutOfBoundException e) { // Exception이 먼저 실행되어 실행되지 않음
    예외 처리2
} 
```

`멀티 catch` 

>  하나의 catch 블록에서 여러 개의 예외를 처리

```java
try {
    ArrayIndexOutOfBoundException 또는 NumberFormatException 발생
        
    Exception 발생
} catch(ArrayIndexOutOfBoundException | NumberFormatException e) {
    예외 처리1
} catch(Exception e) {
    예외 처리2
} 
```



### 예외 떠넘기기

> throws 키워드를 사용하여 메소드에서 처리하지 않은 예외를 호출한 곳으로 떠넘김
>
> 단, 호출한 곳에서 반드시 try-catch 블록으로 예외 처리를 해줘야 함.

```java
리턴타입 메소드명(매개변수,...) throw 예외클래스1, 예외클래스2, ... {
    
}
```

```java
	public void test1() {
		try {
			this.readAll();
			readCondition("KBS     ");
		} catch (ClassNotFoundException e) { // 호출한 곳에서 반드시 try - catch 블록으로 예외 처리 해줘야 함!
			e.printStackTrace();
		} catch (SQLException e) {
			e.printStackTrace();
		}
        
    public void readAll() throws SQLException, ClassNotFoundException { // 호출한 곳에서 예외 처리
	
		Connection con = this.getConnection();  
		Statement stmt = con.createStatement();
		String sql = "select * from userTBL";
		ResultSet rs = stmt.executeQuery(sql);
		while(rs.next()) {
			System.out.println(rs.getString("userId")+","+rs.getString("userName")+","+rs.getInt("birthYear"));
		}		
		rs.close();
		stmt.close();
		con.close();
```

























