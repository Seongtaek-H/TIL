## 클래스-메소드

### 메소드

> 객체의 동작에 해당하는 중괄호 {} 블록. 필드를 읽고 수정하고, 다른 객체를 생성해서 다양한 기능을 수행한다.
>
> 객체 간 데이터 전달의 수단으로 사용되며, 외부로부터 매가값을 받을 수도 있고, 실행 후 어떤 값을 리턴할 수도 있음



#### 메소드 선언

```java
리턴타입 메소드명 ([매개변수선언, ...]){
    // 메소드 실행 블록
}
```

`리턴 타입` : 메소드가 실행 후 리턴하는 값의 타입

* 리턴값이 없는 경우 : 리턴 타입에 void 가 옴. 단순히 메소드만 호출 가능.

* 리턴값이 있는 경우 : 메소드의 결과가 리턴값의 타입이 와야함. 호출할 때에는 리턴값을 저장할 <B>변수</B>가 있어야 함

  ```java
  void powerOn(){...}
  double divide(int x, int y){...}
  
  powerOn(); // 리턴값이 없으므로 메소드만 호출 가능
  double result = divide(10,20); // divide 리턴값을 result 변수에 저장하여 호출
  ```



`메소드 이름` 

* 숫자로 시작하면 안되고, $, _ 를 제외한 특수 문자 X
* 관례적으로 소문자로 작성
* 다른 단어가 혼합된 이름이면 뒤이어 오는 단어의 첫머리 글자는 대문자로 작성



`매개 변수` : 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용

```java
double divide(int x, int y){...}

// divide 메소드를 호출하기 위해서는 반드시 두개의 int 타입의 값을 주어야 함
double result = divide(10,20);
```

* 매개값은 반드시 매개 변수의 타입에 부합되는 값이어야 함!
* 매개값이 매개 변수 타입이 아닐지라도 자동 변환 가능한 경우라면 사용할 수 있음 (권장하지 않음)



#### 리턴문

`리턴값이 있는 메소드` 

> 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야 됨
>
> 리턴문이 없다면 컴파일 오류가 발생하며, 리턴문이 실행되면 메소드는 즉시 종료됨

```java
return 리턴값;
```

* 리턴문의 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 함

* 리턴문 이후 실행문은 실행되지 않아서 컴파일 오류가 발생

* 다만, if문 끝에 리턴문이 있는 경우 if문의 조건식이 성립하면 순서대로 실행되지 않기 때문에 컴파일 오류 발생하지 않음

  ```java
  boolean isLeftGas(){
      if(gas==0){
          System.out.println("gas가 없습니다.");
      	return false; // 즉시 메소드가 종료되며 return값은 false로 리턴함
      }
      System.out.println("가스가 있습니다.")
      return true; // if문의 조건식이 false일 경우에만 실행되며 return값을 true로 리턴
  }
  ```



`리턴값이 없는 메소드 : void`

* void로 선언된 리턴값이 없는 메소드에서도 return문을 사용할 수 있음
* return; 으로 사용하며 사용 즉시 메소드를 강제 종료



#### 메소드 호출

* 클래스 내부에서 호출 : 단순한 메소드 이름으로 호출

```java
// 클래스 내부에서 호출
public class ClassName {
    void method1() {
        //method2 호출 -> 리턴값 없음
        method1("김개똥",30)
        //method3 호출 -> 리턴값 있으므로 변수를 선언하고 대입해야 함
        int sum = method3(30,20);
    }
    
    void method2 (String name, int age){
        
    }
    
    int method3(int x, int y){
        int result = x +y;
        return result;
    }
}
```



* 클래스 외부에서 호출 : 클래스로부터 객체를 생성. 객체가 존재해야 메소드도 존재하기 때문! 그 후 참조 변수와 도트 연산자를 이용해서 메소드를 호출. 

```java
// 클래스 외부에서 호출
클래스명 참조변수 = new 클래스명(매개값,...); // 클래스로부터 객체 생성

참조변수.메소드명(매개값,...); 			// 리턴값이 없거나, 있어도 리턴값을 받지 않을 경우
타입 변수 = 참조변수.메소드명(매개값,...); // 리턴값이 있고, 리턴값을 받을 경우

Car myCar = new Car(); // 객체 생성
myCar.keyTurnOn();		// keyTurnOn 메소드 호출(리턴값 없거나 안받음)
myCar.run();			// run 메소드 호출(리턴값 없거나 안받음)
int speed = myCar.getSpeed(); // speed 라는 변수에 getSpeed 메소드의 리턴값을 저장하는 것으로 호출
```



`메소드 오버로딩` : 매개값을 다양하게 받아 처리할 수 있도록 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것. 

* 매개 변수의 타입, 개수, 순서 중 하나가 달라야 함
* 리턴 타입은 메소드 오버로딩과는 무관함
* 매개 변수의 타입, 개수 , 순서가 같고 매개 변수 이름만 바꾸는 것은 메소드 오버로딩이 아님

```java
int plus(int x, int y){
    int result = x+y;
    return result;
}

double plus(double x, double y){
    double result = x+y;
    return result;
}

plus(10,20); 		// int plus 메소드 실행
plus(10.5,20.5);    // double plus 메소드 실행 

plus(10, 20.5); 	// double plus 메소드 실행. 매개 변수 타입이 일치하지 않을 경우 자동타입변환 가능한 메소드 선택하여 실행
```







