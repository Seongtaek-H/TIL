## Promise

> ìžë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì œê³µí•˜ëŠ” ë¹„ë™ê¸°ë¥¼ ê°„íŽ¸í•˜ê²Œ ì²˜ë¦¬í• ìˆ˜ ìžˆë„ë¡ ë„ì™€ì£¼ëŠ” ì˜¤ë¸Œì íŠ¸
>
> ì •í•´ì§„ ìž¥ì‹œê°„ì˜ ê¸°ëŠ¥ì„ ìˆ˜í–‰í•˜ê³  ë‚˜ì„œ ì •ìƒì ìœ¼ë¡œ ê¸°ëŠ¥ì´ ìˆ˜í–‰ì´ ë˜ì–´ì¡Œë‹¤ë©´ ì„±ê³µ ë©”ì‹œì§€ì™€ ì²˜ë¦¬ëœ ê°’ì„ ì „ë‹¬
>
> ì˜ˆìƒì¹˜ ëª»í•œ ë¬¸ì œ ë°œìƒí•˜ë©´ ì—ëŸ¬ ì „ë‹¬

promise is a JavaScript object for asynchronous operation. 

í”„ë¡œë¯¸ìŠ¤ëŠ” ìžë°”ìŠ¤í¬ë¦½íŠ¸ ì•ˆì— ë‚´ìž¥ëœ ë¹„ë™ê¸°ì ì¸ ê²ƒì„ ìˆ˜í–‰í•  ë•Œ ì½œë°± í•¨ìˆ˜ ëŒ€ì‹  ì“°ì´ëŠ” ìœ ìš©í•œ ì˜¤ë¸Œì íŠ¸

state: pending(ì˜¤í¼ë ˆì´ì…˜ì´ ìˆ˜í–‰ì¤‘ì¼ ë•Œ) -> fulfilled(ì˜¤í¼ë ˆì´ì…˜ì´ ì„±ê³µì ìœ¼ë¡œ ë) or rejected (íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ê±°ë‚˜ ë„¤íŠ¸ì›Œí¬ ë¬¸ì œê°€ ìƒê¸°ë©´)

Producer(ì›í•˜ëŠ” ê¸°ëŠ¥ì„ ìˆ˜í–‰í•´ì„œ í•´ë‹¹í•˜ëŠ” ë°ì´í„°ë¥¼ ë§Œë“¤ì–´ë‚´ëŠ” promise object) vs Consumer(ì›í•˜ëŠ” ë°ì´í„°ë¥¼ ì†Œë¹„í•˜ëŠ”)

```js
// 1. Producer

// í”„ë¡œë¯¸ìŠ¤ëŠ” í´ëž˜ìŠ¤ì´ê¸° ë•Œë¬¸ì— new í‚¤ì›Œë“œë¡œ ì˜¤ë¸Œì íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ìžˆìŒ
// í”„ë¡œë¯¸ìŠ¤ì˜ ìƒì„±ìžë¥¼ ë³´ë©´ executor ë¼ëŠ” ì½œë°±í•¨ìˆ˜ë¥¼ ì „ë‹¬í•´ì¤˜ì•¼í•˜ëŠ”ë°, ì´ ì½œë°± í•¨ìˆ˜ì—ëŠ” ë˜ ë‹¤ë¥¸ ë‘ê°€ì§€ ì½œë°± í•¨ìˆ˜ë¥¼ ë°›ìŒ
// ê¸°ëŠ¥ì„ ì •ìƒì ìœ¼ë¡œ ìˆ˜í–‰í•´ì„œ ë§ˆì§€ë§‰ì— ìµœì¢… dataë¥¼ ì „ë‹¬í•˜ëŠ” resolve ì½œë°± í•¨ìˆ˜
// ê¸°ëŠ¥ì„ ìˆ˜í–‰í•˜ë‹¤ê°€ ì¤‘ê°„ì— ë¬¸ì œê°€ ìƒê¸°ë©´ í˜¸ì¶œí•˜ê²Œ ë  reject ì½œë°± í•¨ìˆ˜

// when new Promise is created, the executor runs automatically. 
// ë¶ˆí•„ìš”í•œ ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë“±ì„ ìˆ˜í–‰í•  ìˆ˜ ìžˆê¸° ë•Œë¬¸ì— ìœ ì˜í•´ì•¼ í•¨.
const promise = new Promise((resolve, reject) => {
    // doing some heavy work (network, read files...). ì‹œê°„ì´ ì¢€ ê±¸ë¦¬ëŠ” ë¬´ê±°ìš´ ë™ìž‘ì€ í”„ë¡œë¯¸ìŠ¤ë¥¼ ë§Œë“¤ì–´ì„œ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬
    console.log('doing something...');
    setTimeout(() => {
        resolve('ellie');
        // reject(new Error('no network'));
    }, 2000);
});

// 2. Consumers: then, catch, finally ë¥¼ ì´ìš©í•´ì„œ ê°’ì„ ë°›ì•„ì˜¬ ìˆ˜ ìžˆìŒ
// then: í”„ë¡œë¯¸ìŠ¤ ê¸°ëŠ¥ì´ ì›í• ížˆ ì´ë£¨ì–´ì¡Œì„ ë•Œ
// catch: ì˜¤ë¥˜ ë°œìƒí–ˆì„ ë•Œ ì—ëŸ¬ë©”ì‹œì§€
// finally: ê¸°ëŠ¥ì´ ì„±ê³µí•˜ë˜ ì‹¤íŒ¨í•˜ë˜ ìˆ˜í–‰
promise
    .then((value) => { // valueë¼ëŠ” íŒŒë¼ë¯¸í„°ëŠ” í”„ë¡œë¯¸ìŠ¤ê°€ ì •ìƒì ìœ¼ë¡œ ìž˜ ìˆ˜í–‰ì´ ë˜ì–´ì„œ ë§ˆì§€ë§‰ resolve ì½œë°± í•¨ìˆ˜ì—ì„œ ì „ë‹¬ëœ ê°’
        console.log(value); // ellie ì¶œë ¥ (2ì´ˆ í›„)
    })
    .catch(error => {
        console.log(error); // í”„ë¡œë¯¸ìŠ¤ì—ì„œ rejectë¥¼ ë¦¬í„´í–ˆì„ ë•Œ ì—ëŸ¬ë¥¼ ì¶œë ¥í•˜ì§€ ì•Šê³  catch ë¸”ë¡ ì‹¤í–‰
    })
    .finally(() => { // ì„±ê³µí•˜ë“  ì‹¤íŒ¨í•˜ë˜ ë¬´ì¡°ê±´ ë§ˆì§€ë§‰ì— í˜¸ì¶œë˜ëŠ” êµ¬ë¬¸
        console.log('finally'); // finally
})

// 3. Promise chaining : í”„ë¡œë¯¸ìŠ¤ì— thenì„ í˜¸ì¶œí•˜ë©´ ë˜‘ê°™ì€ í”„ë¡œë¯¸ìŠ¤ë¥¼ í˜¸ì¶œí•˜ê¸° ë•Œë¬¸ì— ê·¸ í˜¸ì¶œëœ í”„ë¡œë¯¸ìŠ¤ì— ë‹¤ì‹œ thenì´ë‚˜ catch í˜¸ì¶œ
const fetchNumber = new Promise((resolve, reject) => {
    setTimeout(() => resolve(1),1000);
});

fetchNumber
    .then(num => num * 2) // 2
    .then(num => num * 3) // 6
    .then(num => { // then ì€ ê°’ì„ ì „ë‹¬í•´ë„ ë˜ê³  ë˜ë‹¤ë¥¸ ë¹„ë™ê¸°ì¸ í”„ë¡œë¯¸ìŠ¤ë¥¼ ì „ë‹¬í•´ë„ ë¨
        return new Promise((resolve, reject) => {
            setTimeout(() => resolve(num-1),1000);
        })
    })
    .then(num => console.log(num)); // 5

// 4. Error Handling
const getHen = () =>
    new Promise((resolve, reject) => {
        setTimeout(() => resolve('ðŸ“'), 1000);
    });
const getEgg = hen =>
    new Promise((resolve, reject) => {
        setTimeout(() => reject(new Error(`${hen} => ðŸ¥š`), 1000));
    });
const cook = egg =>
    new Promise((resolve, reject) => {
        setTimeout(() => resolve(`${egg} => ðŸ³`), 1000);
    });

// getHen()
//	.then(hen => getEgg(hen)) //  .then(getEgg) : ì½œë°±í•¨ìˆ˜ë¥¼ ì •ì˜í• ë•Œ ë°›ì•„ì˜¤ëŠ” ë°¸ë¥˜ë¥¼ ë‹¤ë¥¸ í•¨ìˆ˜ë¡œ ë°”ë¡œ í•˜ë‚˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²½ìš° ìƒê°¹ê°€ëŠ¥
//	.then(egg => cook(egg)) 	//	.then(cook) 
//  .then(meal => console.log(meal)); // then(console.log) // ðŸ“ => ðŸ¥š => ðŸ³

ë‹¬ê±€ì„ ë°›ì•„ì˜¤ëŠ” ë¶€ë¶„ì—ì„œ ë„¤íŠ¸ì›Œí¬ ë¬¸ì œê°€ ìƒê²¨ì„œ ì‹¤íŒ¨ê°€ ë˜ë©´?
// const getEgg = hen =>
//    new Promise((resolve, reject) => {
//        setTimeout(() => reject(new Error(`error! ${hen} => ðŸ¥š`), 1000));
//    });

getHen() //
.then(getEgg)
.catch(eroor => {
    return 'ðŸž';
})
.then(cook)
.then(console.log)
.catch(console.log); // ðŸž => ðŸ³
```



ì½œë°± ì§€ì˜¥ í”„ë¡œë¯¸ìŠ¤ë¡œ í•´ê²°í•˜ê¸°

```js
console.clear();
class UserStorage {
    loginUser(id, password) {
      return new Promise((resolve, reject)=>{
      	setTimeout(() => {
        	if (
            (id === 'ellie' && password === 'dream') ||
            (id === 'coder' && password === 'academy')
          ) {
            resolve(id);
        	} else {
            reject(new Error('not found'));
        	}
        }, 2000);
    	});
  
    getRoles(user) {
			return new Promise((resolve, reject)=>{
    	  setTimeout(() => {
        	if (user === 'ellie') {
            resolve({ name: 'ellie', role: 'admin' });
        	} else {
            reject(new Error('no access'));
        	}
        }, 1000);
      });
		}

const userStorage = new UserStorage();
const id = prompt('enter ur id');
const password = prompt('enter ur pw');
userStorage.loginUser(
    id,
    password,
    user => {
        userStorage.getRoles(
            user,
            userWithRole=>{
                alert(`hello ${userWithRole.name}, you have a ${userWithRole.role}`);
            },
            error => {console.log(error);});
    },
    error => {console.log(error);}
);
```

