## 문제 해결 패턴



### HOW DO YOU IMPROVE?

1. **Devise** a plan for solving problems
2. **Master** common problem solving patterns

​		-> Problem solving patterns



### Frequency counters 

빈도 카운터를 사용하는 방법은 기본적으로 객체를 사용하는 것

객체를 사용해서 프로필을 만든다고 하면 배열이나 스트링의 요소 즉 배열과 스트링 같은 직선구조를 가지고 작업을 한다는 말

그러면 다른 배열이나 스트링을 가지고 만든 다른 객체와 이것을 빠르게 비교할 수 있다

두개의 배열을 객체로 쪼개서 만들고 그 안에 있는 것들을 분류한 다음에 두 객체를 비교할 수 있음



Ex) Write a function called **same**, which accepts two arrays. The function should return true if every value in the array has it's corresponding value squared in the second array. The frequency of values must be the same.

```js
same([1,2,3], [4,1,9]) // true
same([1,2,3], [1,9]) // false
same([1,2,1], [4,4,1]) // false (must be same frequency)
```

##### A NAIVE SOLUTION : Time Complexity - N^2

```
function same(arr1, arr2){
    if(arr1.length !== arr2.length){
        return false;
    }
    for(let i = 0; i < arr1.length; i++){
        let correctIndex = arr2.indexOf(arr1[i] ** 2)
        if(correctIndex === -1) {
            return false;
        }
        arr2.splice(correctIndex,1)
    }
    return true
}
```

##### REFACTORED : Time Complexity - O(n)

```
function same(arr1, arr2){
    if(arr1.length !== arr2.length){
        return false;
    }
    let frequencyCounter1 = {}
    let frequencyCounter2 = {}
    for(let val of arr1){
        frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1
    }
    for(let val of arr2){
        frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1        
    }
    for(let key in frequencyCounter1){
        if(!(key ** 2 in frequencyCounter2)){
            return false
        }
        if(frequencyCounter2[key ** 2] !== frequencyCounter1[key]){
            return false
        }
    }
    return true
```



### ANAGRAMS

빈도 카운터 패턴을 이용. 두 개의 스트링을 비교하여 같은 문자가 같은 빈도로 있는지 확인함



### MULTIPLE POINTERS

Creating **pointers** or values that correspond to an index or position and move towards the beginning, end or middle based on a certain condition

**Very** efficient for solving problems with minimal space complexity as well