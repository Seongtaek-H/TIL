프로세스와 쓰레드

프로세스 : 운영체제 위에서 연속적으로 실행되고 있는 프로그램

각각의 프로세스는 서로 독립적으로 메모리 위에서 실행됨

각각의 프로세스는 저마다 리소스 자원들이 정해져있는데, 즉 프로세스마다 할당된 메모리 데이터들이 지정되어 있음

프로세스 안에는 프로그램을 위해서 작성된 코드, 즉 프로그램을 실행하기 위한 코드

함수들이 어떤 순서로 실행되어야 하는지 이 함수가 끝나면 어디로 다시 돌아가야 되는지에 대한 정보를 저장하고 있는 스택

힙은 오브젝트를 생성하거나 데이터를 만들 때 그 데이터들이 저장되는 공간

힙에는 동적으로 할당된 변수들이 저장되는 반면에, 데이에는 전역 변수나 스태틱 변수들이 할당되어짐

각각의 프로세스는 자기들에게 필요한 코드, 동작하고 있는 순서를 기억하는 스택, 데이터들이 들어있는 힙과 데이터들이 들어져 있음

<img src="/Users/seongtaek/project/TIL/브라우저/프로세스.png" alt="프로세스"  />

쓰레드는 한 프로세스 안에 여러 개가 동작할 수 있는데, 쓰레드는 각각 저마다 해야 되는 업무를 배정받음 (=일꾼이라고도 불림)

쓰레드는 저마다 필요한 일들을 수행하게 되고, 자기들만의 수행해야되는 함수의 호출을 기억해야 되기 때문 쓰레드마다 스택이 할당되어져 있음

프로세스 안에서 동작하는 일꾼들은 결국 한 프로그램을 위해서 일해야 되므로 프로세스에 지정된 코드와 데이터 힘들을 공통적으로 접근해서 공통적으로 업데이트 가능

쓰레드는 동시다발적으로 발생할 수 있기 때문에 프로세스가 조금 더 효율적으로 일을 할 수 있도록 도움을 주는 역할

쓰레드들이 안에 들어있기 때문에 다양한 일들을 동시에 할 수 있음 (음악을 재생하면서 사진 편집 작업)

쓰레드는 자신들이 일을 수행할 때 어디에서부터 어디까지 일을 했고, 그 다음엔 어디로 가야 되는지 일의 흐름을 기억할 수 있는 고유의 스택이 지정되어져 있지만,

데이터나 코드나 힙 같은 공통적인 데이터 리소스는 프로세스에 있기 때문에 쓰레드들은 이 프로세스에 공통적으로 할당된 리소스에 동시 다발적으로 접속해서

동시다발적으로 업데이트 해야돼서 서로 공유하면서 사용

멀티쓰레딩이 어려운 이유는 멀티쓰레딩을 잘 못하면 공통적으로 업데이트하면서 순서가 맞지 않거나 하면 발생할 수 있는 문제점이 있기 때문

프로세스는 프로그래밍을 동작하는 최고의 단위

쓰레드는 프로그램 안에서 동시에 여러 개가 수행될 수 있는 작은 일꾼 단위

<img src="/Users/seongtaek/project/TIL/브라우저/쓰레드.png" alt="쓰레드"  />



자바스크립트는 싱글스레드 언어임. 언어 자체에는 멀티쓰레딩이 없음

자바스크립트 자체에는 멀티쓰레딩을 하는 기능이 없지만 자바스크립트가 동작하는 브라우저에는 여러 가지 쓰레드가 있음

그래서 웹API를 이용하면 멀티쓰레딩이 가능

자바스크립트가 동작하는 런타임 환경, 즉 자바스크립트가 동작하고 있는 실행 환경에서는 다양한 방식을 이용해서 조금 멀티쓰레딩 같은 효과 얻을 수 있음

자바스크립트가 동작하고 있는 실행 환경에서는 멀티쓰레딩 뿐만아니라 이벤트 루프를 이용해서 조금 더 다양한 동작을 실행할 수 있음



자바스크립트 엔진 안에는 메모리힙과 콜스택이 들어있음

메모리힙은 데이터를 만들 때, 즉 변수를 선언해서 오브젝트를 할당하거나, 문자열이나 숫자를 할당하게 되면 데이터들은 전부 다 메모리 힘에 저장됨

메모리힙은 구조적으로 정리된 자료구조가 아니라 자료들이 여기저기 아무곳에나 저장되어져있음

콜스택은 함수를 실행하는 순서에 따라서 차곡차곡 쌓아놓는 역할

스택은 LIFO(Last In First Out)

![콜스택](/Users/seongtaek/project/TIL/브라우저/콜스택.png)

콜스택은 함수들이 호출하는 순서를 기억했다가 함수가 끝나면 원래 있던 자리로 돌아가기 위해서 쓰이는 자료구조 중에 하나

모든 프로세스와 쓰레드 안에는 각각 저마다의 콜스택이 들어가 있음

함수 안에서 자기 자신을 계속 부르는 것을 재귀함수라고 하는데 재귀함수를 잘못쓰면 콜스택이 넘치게됨



브라우저 런타임 환경

웹 API는 브라우저에서 제공하는 API 이기 때문에 웹 API 를 활용하면 브라우저의 멀티스레딩을 이용해서 조금 더 다양한 일들을 동시에 실행할 수 있음

setTimeout을 호출하는 순간 setTimeout 은 콜백에서 지워지고 웹 API는 타이머를 시작하게 됨

타이머와 자바스크립트 엔진은 병렬적으로 실행이되고 있다가 지정된 시간이 끝나면 웹API는 태스크 큐에 setTimeout에 등록한 콜백 함수를 태스크큐에 집어넣음

큐? FIFO (First In First Out) 처음에 들어온 애가 젤 처음으로 나감 큐에 대표적인 API 로는 add 와 remove가 있음

태스크큐에 있는 콜백은 언제 실행이 될까?

태스크큐와 콜스택을 관찰하는 이벤트 루프 루프를 계속 빙글빙글 돌면서 콜스택과 태스크큐를 관찰

콜스택이 비어서 자바스크립트 엔진이 더이상 일을 하고 있지않을때 태스크큐에 있는 콜백함수를 콜스택으로 데리고 옴 그러면 자바스크립트 엔진이 콜백함수 실행

이벤트루프는 프로세스가 동작하는 동안 계속 빙글빙글 루프를 돌면서 콜스택이 비어져있으 태스크큐에 있는 아이를 콜스택으로 가져와서 자바스크립트 엔진이 수행할 수 있도록 도와줌

태스크큐에 있는 콜백함수는 이벤트루프에 의해 한번 에 하나만 콜스택으로 옮겨짐



콜스택에서 수행되고 있는 코드는 끝날때까지 보장이 된다. 중간에 다른 코드가 끼어들 수 없음

태스크큐는 웹API에서 우리가 등록한 콜백함수를 지정된 이벤트가 발생했을때 태스크큐에 넣음

마이크로 태스크큐는 우리가 흔히 쓰는 프로미스에 등록된 콜백, 즉 프로미스가 다 수행이 되고 나면 그 다음에 then에 등록한 콜백함수, mutation observer라는 웹API 에 등록되있는 콜백들이 마이크로 태스크 큐에 들어옴

render는 주기적으로 브라우저에서 우리가 요소들을 움직이거나 애니메이션 할 때 주기적으로 브라우저에 업데이트 해줘야 하는데 그 때 주기적으로 화면에 업데이트해주는것

브라우저에서 우리가 변형하는 DOM 요소를 변형한 것이 브라우저에 표기되기 위해서는 렌더 트리가 만들어져야하고, 레이아웃 크기,위치들이 계산된 다음에 paint와 composite 과정을 통해 브라우저에 표기. 리퀘스트 애니매이션 프레임이라는 웹API를 통해서 콜백을 등록해 놓으면 브라우저가 업데이트되기 전에 내 콜백을 실행해줘라는 API. 그때 우리가 호출하는 콜백은 이 리퀘스트 애니메이션 프레임 큐에다가 차곡차곡 쌓여짐

태스크큐에는 우리가 흔히 쓰는 콜백 함수들이 들어오게 되고, 마이크로태스크큐는 프로미스를 쓰면 프로미스에 등록된 콜백이 들어오게 되고, 렌더는 브라우저에서 우리가 변형한 코드가 주기적으로 업데이트되기 위해서 주기적으로 호출되는 순서인데 그전에 우리가 리퀘스트 애니메이션 프레임이라는 API를 부르면 그때 우리가 등록한 콜백은 이 리퀘스트애니메이션프레임 안에 들어있는 큐에 차곡차곡 쌓인다.

![이벤트루프](/Users/seongtaek/project/TIL/브라우저/이벤트루프.png)



이벤트루프는 while(true){} 같은 애를 이용해서 계속 빙글빙글 도는 루프 중에 하나

이벤트루프가 평소에는 빙글빙글 돌다가 콜스택에 무언가가 있다면 즉, 콜스택에서 수행중인 함수가 있다면 끝날 때까지 콜스택에 머물러있음 

그래서 콜스택에서 굉장히 시간이 오래 걸리는 것을 하게 되면 사용자에게 더이상 화면이 업데이트 되어져서 보이지가 않음

그리고 다른 클릭이 발생해도 그 클릭에 등록된 콜백함수가 실행이 되지 않음.

머물러 있다가 function 이 끝나면 그때서야 다시 빙글빙글 돌기 시작하는데 렌더 쪽으로는 갈수도있고 안갈수도있음 

브라우저에서는 우리가 업데이트 하는 내용들을 사용자에게 60fps(16.7ms), 즉 1초동안 60개의 프레임을 보여주도록 노력하는데

이게 무슨말이냐면 사람눈에 애니메이션이 자연스러워 보이기 위해서는 1초당 60개의 그림이 필요 

그래서 브라우저 위에서도 사용자의 눈에 자연스럽게 애니메이션이 된다는 느낌을 받게 하기 위해서는 1초당 60개의 프레임을 보여줘야함

그렇게 하기 위해서는 16.7ms 동안 업데이트가 일어나야된다는 말인데 

그래서 이벤트 루프는 엄청나게 빠른 속도로 돌고있고 이벤트 루프는 한바퀴 도는데 1ms 도 안걸림 그래서 매번 1ms마다 렌더 업데이트를 할 필요가 없음

그래서 어느 정도 시간 있다가 브라우저마다 지정된 시간이 조금 다르긴 한데 대부분은 16.7ms 범위 안에서 렌더를 한 번 업데이트 해주고 

그다음에 다시 다른일을 하다가

시간이 돼면 다시 렌더 트리를 업데이트 했다가 다시 몇바퀴 돌다가 다시 나중에 업데이트 하는 방식으로 운영

이벤트 루프는 아까 2ms 전에 렌더를 한번 거쳐갔기 때문에 렌더를 건너뛰고 바로 마이크로 태스크큐로 넘어가게 됨

마이크로 태스크 큐에 뭔가 있으면 멈춰서서 마이크로 태스크큐 안에 들어있는 아이템들이 없을때까지 기다렸다가 하나하나씩 then 콜백을 콜 스택에 넣게 됨

포인트는 여기에 머물러 있는 동안 마이크로 태스크큐에 또다른 콜백이 들어온다면 나중에 들어온 콜백도 전부다 끝날때까지 마이크로 태스크큐가 텅텅 빌때까지 콜스택으로 가지고와서 수행

이제 마이크로 태스크큐가 텅텅비면 태스크큐로 넘어가고 태스크큐에서는 한번에 하나의 콜백만 콜스택으로 가져오게 되고 다시 콜스택에서 콜백이 끝날때까지 기다림

콜스택에 있는 콜백 함수가 다 끝나고 나서야 이벤트루프는 다시 동그라미 순회 시작

브라우저에 업데이트 할 때가 되었으면 렌더 시퀀스에 들어와서 리퀘스트 애니메이션 프레임을 통해서 등록된 콜백 함수들을 천천히 하나 하나씩 다 실행한 다음에 

렌더 트리로 와서 렌더 트리를 만들고 그 트리를 이용해서 레이아웃을 계산한 다음에 그 다음에 페인트를 통해서 브라우저에 업데이트를 한 다음에 다시 이벤트 루프는 가는 길을 다시 가기 시작



이벤트리스너에 콜백함수가 등록되어지면 이게 태스크큐로 넘어가고 이벤트루프가 이걸 콜스택으로 옮긴다음에 모두 수행이 되면 다시 돌기 시작해서 렌더시퀀스로 가서 한번에 렌더링하기 때문에 이벤트리스너 콜백함수내의 엘리먼트 생성, 스타일 생성 등의 순서는 상관없고, x축으로 갔다가 y축으로 다시 이동하는 애니메이션 로직을 한번에 넣으면 당연히 한번에 계산해서 렌더링되기때문에 의도한대로 동작안함

콜백안에서 DOM요소를 아무리 조작해서 업데이트한다고 해도 브라우저에는 변경된 사항이 바로바로 보여지지가 않음 콜백이 끝난 다음에 그때서야 브라우저에 업데이트된 사항이 나타남

콜스택에 함수가 있으면 이벤트루프가 계속해서 콜스택에 머물고 순회를 하지않기 때문에 브라우저가 업데이트도 안되고 클릭 처리도 안되기 때문에 콜스택에 오래 머물게 하는건 좋지않음 끝나지 않는 함수(재귀함수)같은 거 조심